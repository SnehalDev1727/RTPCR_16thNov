"use strict";

const userDataDir = process.env.NINJAQPCR_HOME || "/home/pi/ninjaqpcr";
console.log("UserDataDir=%s", userDataDir)
console.log("Platform=%s", process.platform);
const isDevEnv = process.platform == "darwin";
/*

  Ninja-qPCR Network configuration server
  
  It provides Wi-Fi configuration service.
  User interface files are stored in assets directory.
  URLs:
    /update : 
  */
const { exec } = require("child_process");
const http = require('http');
var URL = require('url');
const fs = require('fs');

const WPA_CONF_HEADER = "# Generated by Ninja-qPCR WiFi config tool.\n" +
  "ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\n" +
  "update_config=1\n" +
  "country=___COUNTRY___\n";
// TODO country

// Development env
let CMD_WPA, PATH_WPA_CONF, PATH_WPA_CONF_TMP, PATH_CONF, SUDO, REBOOT, PORT;
if (isDevEnv) {
  CMD_WPA = "./wpa_passphrase";
  PATH_WPA_CONF = "./wpa_supplicant.conf";
  PATH_WPA_CONF_TMP = "./wpa_supplicant_temp";
  PATH_CONF = userDataDir + "/network.json";
  SUDO = "";
  REBOOT = "touch dummy_reboot;";
  PORT = 8080;
} else {
  // @RPi
  CMD_WPA = "wpa_passphrase";
  PATH_WPA_CONF = "/etc/wpa_supplicant/wpa_supplicant.conf";
  PATH_CONF = userDataDir + "/network.json";
  PATH_WPA_CONF_TMP = userDataDir + "/wpa_supplicant_temp";
  SUDO = "sudo";
  REBOOT = "sudo reboot";
  PORT = 8080;
}
console.log("CMD_WPA=%s", CMD_WPA);
console.log("PATH_WPA_CONF=%s", PATH_WPA_CONF);
console.log("PATH_WPA_CONF_TMP=%s", PATH_WPA_CONF_TMP);
console.log("PATH_CONF=%s", PATH_CONF);
console.log("PORT=%s", PORT);


class WifiConfServer {
  constructor () {
    this.conf = {};
  }
  saveConf (callback) {
    
  }
  loadConf (callback) {
    console.log("Reading config from %s", PATH_CONF);
    fs.readFile(PATH_CONF, (err, rawData)=>{
      try {
        this.conf = JSON.parse(rawData);
        console.log(this.conf);
        console.log("Start listening to port %d", PORT);
        callback();
      } catch (ex) {
        console.log(ex);
        callback();
      }
    });
  }
  init () {
    this.loadConf(()=>{
      console.log("Starting server");
      this.server = http.createServer();
      this.server.listen(PORT);
      this.server.on('request', (req, res)=>{
        const url = URL.parse(req.url).pathname;
        res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With,content-type');
        try {
          if (url == "/list") {
            this.list(req, res);
          } else if (url == "/update") {
            this.update(req, res);
          } else if (url == "/reboot") {
            this.reboot(req, res);
          } else {
            this.responseStatic(url, res);
            
          }
        } catch (ex) {
          console.error(ex);
        }
      });
    });
  }
  
  responseStatic (url, res) {
    if (url == "/") {
      url = "/index.html"
    }
    fs.readFile("assets" + url, (err, rawData)=>{
      if (!err) {
        let contentType = 'text/html; charset=UTF-8';
        if (url.match(/\.css$/)) {
          contentType = 'text/css; charset=UTF-8';
        }
        res.writeHead(200,{'Content-Type': contentType});
        res.write(rawData);
      } else {
        res.writeHead(404,{'Content-Type': 'application/json'});
        res.write("Not found.");
      }
      res.end();
    });
  }
  list (req, res) {
    let resConf = JSON.parse(JSON.stringify(this.conf));
    if (resConf.networks) {
      for (let network of resConf.networks) {
        network.passphraseUpdated = false;
        if (network.passphrase != null && network.passphrase.length > 0) {
          network.passphrase_dummy = "........";
        }
        network.passphrase = "";
      }
    }
    console.log(JSON.stringify(resConf));
    res.write(JSON.stringify(resConf));
    res.end();
  }
  
  reboot (req, res) {
    const content = {
      success:true
    };
    res.write(JSON.stringify(content));
    res.end();
    this.execCmd (REBOOT, ()=>{});
    
  }
  isValidCountry (country) {
    return country != null && country.length == 2;
  }
  update (req, res) {
    req.on("data", (rawData)=>{
      const data = JSON.parse(rawData);
      const country = data.country;
      const networks = data.networks;
      // TODO networks
      let validNetworks = [];
      let validationErrors = [];
      let response = {
        messages:[],
        isValid: true
      };
      if (!this.isValidCountry(country)) {
        response.messages.push("Please select your country.");
        response.isValid = false;
        
      }
      if (Array.isArray(networks)) {
        for (let network of networks) {
          console.log(network);
          if (this.isEmpty(network)) {
            // Skip empty data.
            continue;
          } else {
            const errors = this.validate(network);
            if (errors.length == 0) {
              // Valid network
              validNetworks.push(network);
            } else {
              validationErrors.push({
                id:network.id,
                errors: errors
              });
            }
          }
        }
        
        if (validNetworks.length == 0 && validationErrors.length == 0) {
          // Empty
          response.isValid = false;
          response.reason = "empty";
          response.messages.push("Please specify at least one SSID.");
        } else if (validationErrors.length) {
          // Has errors
          response.isValid = false;
          response.reason = "invalid";
          response.messages.push("Some fields have errors.");
          response.errors = validationErrors;
        }
      } else {
        // Empty.
        response.isValid = false;
        response.messages("Invalid data format. It is caused by program error. Please contact the devepoper.");
        response.reason = "malformed";
      }
      
      console.log("Response")
      console.log(JSON.stringify(response));
      if (response.isValid) {
        this.updateConfig(country, validNetworks, (error)=>{
          res.writeHead(200,{'Content-Type': 'application/json'});
          if (error) {
            response.isValid = false;
            response.reason = "save_failure";
            response.messages.push("Failed to save.");
            response.error = error.toString();
          }
          res.write(JSON.stringify(response));
          res.end();
        });
      } else {
        res.writeHead(200,{'Content-Type': 'application/json'});
        res.write(JSON.stringify(response));
        res.end();
      }
    });
    
  }
  isEmpty (network) {
    return network.ssid == null || network.ssid.length == 0;
  }
  validate(network) {
    let errors = [];
    if (network.passphraseUpdated) {
      const pass = network.passphrase;
      if (pass != null && pass.length > 0 && (pass.length < 8 || pass.length > 63)) {
        errors.push({
          field:"passphrase",
          message:"Passphrase must be 8..63 characters."
        });
      }
    }
    if (network.priority && network.priority.length > 0) {
      const parsed = parseInt(network.priority);
      if (parsed < 0) {
        errors.push({
          networkId:network.id,
          field:"priority",
          message:"Priority should be a valid integer."
        });
      }
    }
    return errors;
  }
  updateConfig (country, networks, callback) {
    // Copy fields (Other fields are deleted before saving)
    const fieldsToKeep = [
      "ssid" , "passphrase", "priority", "hidden"
    ];
    let saveData = {
      country:country,
      networks:[]
    };
    let wpaConfElements = [WPA_CONF_HEADER.replace("___COUNTRY___",country)];
    for (let network of networks) {
      let lines = [];
      lines.push("network={");
      lines.push('ssid="' + this.escape(network.ssid) + '"');
      if (!network.isNew && !network.passphraseUpdated) {
        // Keep existing password
        const oldConf = this.conf.networks[network.id];
        network.passphrase = oldConf.passphrase;
      }
      lines.push('psk="' + this.escape(network.passphrase) + '"');
      if (network.priority) {
        lines.push("priority=" + network.priority)
      }
      if (network.hidden) {
        // Stealth
        lines.push("scan_ssid=1");
      }
      lines.push("}");
      wpaConfElements.push(lines.join("\n"));
      let obj = {};
      for (let field of fieldsToKeep) {
        if (network[field] != null) {
          obj[field] = network[field];
        }
      }
      saveData.networks.push(obj);
    }
    const wpaConfContent = wpaConfElements.join("\n");
    console.log(wpaConfContent)
    console.log(JSON.stringify(saveData));
    
    fs.writeFile(PATH_CONF, JSON.stringify(saveData), (err)=>{
      console.error(err);
      if (err != null) {
        callback(err);
        return;
      }
      fs.writeFile(PATH_WPA_CONF_TMP, wpaConfContent, (err)=>{
        console.error(err);
        if (err != null) {
          callback(err);
          return;
        }
        const command = SUDO + " mv -f " + PATH_WPA_CONF_TMP + " " + PATH_WPA_CONF + ";"
        this.execCmd(command, (err)=>{
          callback(err);
        });
      });
    });
  }
  escape (str) {
    if (str == null) return "";
    return str.replace(new RegExp("\"", "g"), "\\\"");
  }
  execCmd (command, callback) {
    console.log("Exec cmd: " + command);
    exec(command, (error, stdout, stderr) => {
      if (error) {
        callback(error.message);
      }
      else if (stderr) {
        callback(stderr);
      } else {
        callback(null);
      }
    });
    
  }
}
new WifiConfServer().init();